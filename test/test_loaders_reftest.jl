# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2026 Hiroharu Sugawara
# Part of BoltzTraP.jl
"""
Reference tests for DFT loaders.

Compare Julia loader output against Python BoltzTraP2 reference data.

Test Materials Policy:
- All materials are tested (including spin-polarized)
- Documentation examples use only non-magnetic materials
"""

using Test
using NPZ
using BoltzTraP
using LinearAlgebra

# Load NCDatasets to trigger ABINIT extension
const HAS_NCDATASETS = try
    using NCDatasets
    true
catch
    false
end

# Path to reference data (generated by Python BoltzTraP2)
const REFTEST_DATA = joinpath(@__DIR__, "..", "reftest", "data")
# Path to original DFT data
const BOLTZTRAP_DATA = joinpath(@__DIR__, "..", "..", "BoltzTraP2-public", "data")

#=
    decode_symbols(bytes)

Decode comma-separated symbols from uint8 array (for NPZ.jl compatibility).
=#
function decode_symbols(bytes::AbstractVector{UInt8})
    s = String(UInt8.(bytes))
    return split(s, ",")
end

#=
    compare_loader_output(data, ref; rtol=1e-10)

Compare Julia loader output against Python reference data.

# Arguments
- `data`: Julia loader output (NamedTuple or DFTData)
- `ref`: Python reference data (Dict from npzread)
- `rtol`: Relative tolerance for floating point comparison

# Notes
- Julia ebands: (nbands, nkpts, nspin) - 3D
- Python ebands: (nbands, nkpts) - 2D (spin channels flattened)
- For nspin=1: Compare Julia ebands[:,:,1] with Python ebands
- For nspin=2: Compare Julia ebands flattened with Python ebands
=#
function compare_loader_output(data, ref; rtol=1e-8, atol=1e-10, skip_nelect=false)
    # Lattice vectors: Julia columns = Python rows (after transpose in generator)
    @test isapprox(data.lattice, ref["lattvec"]; rtol=rtol, atol=atol)

    # Positions: Julia (3, natom), Python (natom, 3)
    @test isapprox(data.positions', ref["positions"]; rtol=rtol, atol=atol)

    # Species: Compare decoded strings
    ref_symbols = decode_symbols(ref["symbols"])
    @test data.species == ref_symbols

    # K-points: Julia (3, nkpts), Python (nkpts, 3)
    @test isapprox(data.kpoints', ref["kpoints"]; rtol=rtol, atol=atol)

    # Fermi level
    @test isapprox(data.fermi, ref["fermi"]; rtol=rtol, atol=atol)

    # Number of electrons
    # GENE format doesn't store nelect, Julia uses -1.0 as placeholder
    if !skip_nelect
        @test isapprox(data.nelect, ref["nelect"]; rtol=rtol, atol=atol)
    end

    # Band energies: Handle shape difference
    julia_nspin = size(data.ebands, 3)
    python_nspin = Int(ref["nspin"])
    ref_ebands = ref["ebands"]

    if julia_nspin == 1 && python_nspin == 1
        # Non-spin-polarized: Julia (nbands, nkpts, 1), Python (nbands, nkpts)
        @test isapprox(data.ebands[:, :, 1], ref_ebands; rtol=rtol, atol=atol)
    elseif julia_nspin == 1 && python_nspin == 2
        # SOC case: Python uses nspin=2 for dosweight but ebands is NOT doubled
        # Julia stores as NSpin=1 (single spin channel)
        @test isapprox(data.ebands[:, :, 1], ref_ebands; rtol=rtol, atol=atol)
    elseif julia_nspin == 2 && python_nspin == 2
        # Spin-polarized: Python flattens spin channels into band dimension
        # Julia (nbands, nkpts, 2) -> Python (nbands*2, nkpts)
        julia_flattened = vcat(data.ebands[:, :, 1], data.ebands[:, :, 2])
        @test isapprox(julia_flattened, ref_ebands; rtol=rtol, atol=atol)
    else
        # Mismatch in spin handling
        @test julia_nspin == python_nspin
    end
end

@testset "Loader Reference Tests" begin

    @testset "VASP loader" begin
        test_cases = [
            # (npz_file, data_dir, description, is_spin_polarized)
            ("vasp_si.npz", "Si.vasp", "Si - non-magnetic semiconductor", false),
            ("vasp_pbte.npz", "PbTe.vasp.unpolarized", "PbTe - thermoelectric", false),
        ]

        for (npz_file, data_dir, description, is_spin) in test_cases
            @testset "$description" begin
                npz_path = joinpath(REFTEST_DATA, npz_file)
                data_path = joinpath(BOLTZTRAP_DATA, data_dir)

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                if !isdir(data_path)
                    @warn "Test data not found: $data_path"
                    @test_skip "Test data not found"
                    continue
                end

                ref = npzread(npz_path)
                data = load_vasp(data_path)

                # DFTData{NSpin} type check
                expected_nspin = is_spin ? 2 : 1
                @test data isa DFTData{expected_nspin}
                @test nspin(data) == expected_nspin

                compare_loader_output(data, ref)
            end
        end
    end

    @testset "QE loader" begin
        test_cases = [
            # (npz_file, data_dir, description, is_spin_polarized)
            ("qe_si.npz", "Si.ESPRESSO/out", "Si - non-magnetic semiconductor", false),
            ("qe_fe.npz", "Fe.ESPRESSO.collinear/out", "Fe - collinear magnetic", true),
            ("qe_cri3.npz", "CrI3.ESPRESSO.antiferro/out", "CrI3 - antiferromagnetic", true),
            ("qe_nitinol.npz", "nitinol.ESPRESSO/out", "NiTi - monoclinic structure", false),
        ]

        for (npz_file, data_dir, description, is_spin) in test_cases
            @testset "$description" begin
                npz_path = joinpath(REFTEST_DATA, npz_file)
                data_path = joinpath(BOLTZTRAP_DATA, data_dir)

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                if !isdir(data_path)
                    @warn "Test data not found: $data_path"
                    @test_skip "Test data not found"
                    continue
                end

                ref = npzread(npz_path)
                data = load_qe(data_path)

                # DFTData{NSpin} type check
                expected_nspin = is_spin ? 2 : 1
                @test data isa DFTData{expected_nspin}
                @test nspin(data) == expected_nspin

                compare_loader_output(data, ref)
            end
        end
    end

    @testset "Wien2k loader" begin
        test_cases = [
            # (npz_file, data_dir, description, is_spin_polarized)
            # Note: SOC (.energyso) uses dosweight=1.0, but bands are NOT doubled.
            # In DFTData{NSpin}, SOC is stored as NSpin=1 (single spin channel).
            ("wien2k_si.npz", "Si", "Si - non-magnetic semiconductor", false),
            ("wien2k_cosb3.npz", "CoSb3", "CoSb3 - skutterudite", false),
            ("wien2k_bi2te3.npz", "Bi2Te3", "Bi2Te3 - topological insulator (SOC)", false),
        ]

        for (npz_file, data_dir, description, is_spin) in test_cases
            @testset "$description" begin
                npz_path = joinpath(REFTEST_DATA, npz_file)
                data_path = joinpath(BOLTZTRAP_DATA, data_dir)

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                if !isdir(data_path)
                    @warn "Test data not found: $data_path"
                    @test_skip "Test data not found"
                    continue
                end

                ref = npzread(npz_path)
                data = load_wien2k(data_path)

                # DFTData{NSpin} type check
                expected_nspin = is_spin ? 2 : 1
                @test data isa DFTData{expected_nspin}
                @test nspin(data) == expected_nspin

                compare_loader_output(data, ref)
            end
        end
    end

    @testset "GENE loader" begin
        test_cases = [
            # (npz_file, data_dir, description, is_spin_polarized)
            ("gene_si.npz", "Si.GENE", "Si - non-magnetic semiconductor", false),
        ]

        for (npz_file, data_dir, description, is_spin) in test_cases
            @testset "$description" begin
                npz_path = joinpath(REFTEST_DATA, npz_file)
                data_path = joinpath(BOLTZTRAP_DATA, data_dir)

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                if !isdir(data_path)
                    @warn "Test data not found: $data_path"
                    @test_skip "Test data not found"
                    continue
                end

                ref = npzread(npz_path)
                data = load_gene(data_path)

                # DFTData{NSpin} type check
                expected_nspin = is_spin ? 2 : 1
                @test data isa DFTData{expected_nspin}
                @test nspin(data) == expected_nspin

                # GENE format doesn't store nelect, so skip that check
                compare_loader_output(data, ref; skip_nelect=true)
            end
        end
    end

    @testset "GENE synthetic triclinic P1" begin
        @testset "Triclinic.GENE.synthetic - triclinic P1 structure" begin
            npz_path = joinpath(REFTEST_DATA, "gene_triclinic_p1.npz")
            data_path = joinpath(BOLTZTRAP_DATA, "Triclinic.GENE.synthetic")

            if !isfile(npz_path)
                @warn "Reference data not found: $npz_path"
                @test_skip "Reference data not found"
            elseif !isdir(data_path)
                @warn "Test data not found: $data_path"
                @test_skip "Test data not found"
            else
                ref = npzread(npz_path)
                data = load_gene(data_path)

                # DFTData{1} type check (non-magnetic)
                @test data isa DFTData{1}
                @test nspin(data) == 1

                # Compare with reference (skip nelect as GENE doesn't store it)
                compare_loader_output(data, ref; skip_nelect=true)

                # Verify triclinic angles
                a1, a2, a3 = data.lattice[:, 1], data.lattice[:, 2], data.lattice[:, 3]
                len1, len2, len3 = norm(a1), norm(a2), norm(a3)

                cos_alpha = dot(a2, a3) / (len2 * len3)
                cos_beta = dot(a1, a3) / (len1 * len3)
                cos_gamma = dot(a1, a2) / (len1 * len2)

                alpha = acosd(clamp(cos_alpha, -1, 1))
                beta = acosd(clamp(cos_beta, -1, 1))
                gamma = acosd(clamp(cos_gamma, -1, 1))

                # All angles should be different from 90°
                @test abs(alpha - 90) > 1  # α ≠ 90°
                @test abs(beta - 90) > 1   # β ≠ 90°
                @test abs(gamma - 90) > 1  # γ ≠ 90°
            end
        end
    end

    @testset "ABINIT loader" begin
        if !HAS_NCDATASETS
            @test_skip "NCDatasets not available"
        else
            test_cases = [
                # (npz_file, data_dir, description, is_spin_polarized)
                ("abinit_si.npz", "Si.abinit", "Si - non-magnetic semiconductor", false),
            ]

            for (npz_file, data_dir, description, is_spin) in test_cases
                @testset "$description" begin
                    npz_path = joinpath(REFTEST_DATA, npz_file)
                    data_path = joinpath(BOLTZTRAP_DATA, data_dir)

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                if !isdir(data_path)
                    @warn "Test data not found: $data_path"
                    @test_skip "Test data not found"
                    continue
                end

                ref = npzread(npz_path)
                data = load_abinit(data_path)

                # DFTData{NSpin} type check
                expected_nspin = is_spin ? 2 : 1
                @test data isa DFTData{expected_nspin}
                @test nspin(data) == expected_nspin

                compare_loader_output(data, ref)
            end
        end
        end  # else HAS_NCDATASETS
    end

    @testset "Synthetic Low-Symmetry Tests" begin
        # Helper function to calculate cell angles
        function calc_angles(lattice)
            a, b, c = norm.(eachcol(lattice))
            cos_alpha = dot(lattice[:, 2], lattice[:, 3]) / (b * c)
            cos_beta = dot(lattice[:, 1], lattice[:, 3]) / (a * c)
            cos_gamma = dot(lattice[:, 1], lattice[:, 2]) / (a * b)
            return (
                α = acosd(clamp(cos_alpha, -1, 1)),
                β = acosd(clamp(cos_beta, -1, 1)),
                γ = acosd(clamp(cos_gamma, -1, 1)),
            )
        end

        # Monoclinic: α=90°, β=100°, γ=90°
        # Triclinic: α=85°, β=80°, γ=75°
        cell_types = [
            ("monoclinic", (α = 90.0, β = 100.0, γ = 90.0)),
            ("triclinic", (α = 85.0, β = 80.0, γ = 75.0)),
        ]

        loaders = [
            ("GENE", "Synthetic.GENE", load_gene, false),
            ("VASP", "Synthetic.vasp", load_vasp, false),
            ("QE", "Synthetic.ESPRESSO", load_qe, true),  # has /out subdir
            ("Wien2k", "Synthetic.W2K", load_wien2k, false),
        ]
        # Add ABINIT only if NCDatasets is available
        if HAS_NCDATASETS
            push!(loaders, ("ABINIT", "Synthetic.abinit", load_abinit, false))
        end

        for (cell_type, expected_angles) in cell_types
            @testset "$cell_type" begin
                npz_path = joinpath(REFTEST_DATA, "synthetic_$cell_type.npz")

                if !isfile(npz_path)
                    @warn "Reference data not found: $npz_path"
                    @test_skip "Reference data not found"
                    continue
                end

                ref = npzread(npz_path)

                for (format_name, dir_prefix, load_fn, has_subdir) in loaders
                    @testset "$format_name" begin
                        # Construct data path
                        if has_subdir
                            data_path = joinpath(BOLTZTRAP_DATA, "$(dir_prefix).$cell_type", "out")
                        else
                            data_path = joinpath(BOLTZTRAP_DATA, "$(dir_prefix).$cell_type")
                        end

                        if !isdir(data_path)
                            @warn "Test data not found: $data_path"
                            @test_skip "Test data not found"
                            continue
                        end

                        data = load_fn(data_path)

                        # Basic structure checks
                        @test data isa DFTData{1}
                        @test size(data.kpoints, 2) == 64  # 4×4×4 MP grid
                        @test size(data.ebands, 1) == 8    # 8 bands

                        # Cell angle verification
                        angles = calc_angles(data.lattice)
                        @test isapprox(angles.α, expected_angles.α; atol = 0.5)
                        @test isapprox(angles.β, expected_angles.β; atol = 0.5)
                        @test isapprox(angles.γ, expected_angles.γ; atol = 0.5)

                        # Compare with reference (skip nelect for formats that don't store it)
                        # Use relaxed tolerance for synthetic data (XML/text format precision limits)
                        # GENE doesn't store nelect, Wien2k calculates it from occupancy (may differ)
                        skip_nelect = format_name in ("GENE", "Wien2k")
                        compare_loader_output(data, ref; skip_nelect = skip_nelect, rtol = 1e-7, atol = 1e-9)
                    end
                end
            end
        end
    end

    @testset "Type Stability: Loaders return concrete DFTData{N}" begin
        # Verify that all loaders return DFTData with concrete type parameter
        # This prevents runtime dispatch issues and ensures type stability

        @testset "VASP loader type stability" begin
            data_path = joinpath(BOLTZTRAP_DATA, "Si.vasp")
            if isdir(data_path)
                data = load_vasp(data_path)
                @test isconcretetype(typeof(data))
                @test typeof(data) == DFTData{1}
            else
                @test_skip "Test data not found"
            end
        end

        @testset "QE loader type stability" begin
            data_path = joinpath(BOLTZTRAP_DATA, "Si.ESPRESSO/out")
            if isdir(data_path)
                data = load_qe(data_path)
                @test isconcretetype(typeof(data))
                @test typeof(data) == DFTData{1}
            else
                @test_skip "Test data not found"
            end
        end

        @testset "Wien2k loader type stability" begin
            data_path = joinpath(BOLTZTRAP_DATA, "Si")
            if isdir(data_path)
                data = load_wien2k(data_path)
                @test isconcretetype(typeof(data))
                @test typeof(data) == DFTData{1}
            else
                @test_skip "Test data not found"
            end
        end

        @testset "GENE loader type stability" begin
            data_path = joinpath(BOLTZTRAP_DATA, "Si.GENE")
            if isdir(data_path)
                data = load_gene(data_path)
                @test isconcretetype(typeof(data))
                @test typeof(data) == DFTData{1}
            else
                @test_skip "Test data not found"
            end
        end

        @testset "ABINIT loader type stability" begin
            if !HAS_NCDATASETS
                @test_skip "NCDatasets not available"
            else
                data_path = joinpath(BOLTZTRAP_DATA, "Si.abinit")
                if isdir(data_path)
                    data = load_abinit(data_path)
                    @test isconcretetype(typeof(data))
                    @test typeof(data) == DFTData{1}
                else
                    @test_skip "Test data not found"
                end
            end
        end

        @testset "DFTK loader type stability" begin
            # DFTK is a weak dependency - test only verifies function signature
            # Full tests require TEST_DFTK=true environment variable
            @test isdefined(BoltzTraP, :load_dftk)
            # Note: load_dftk requires DFTK.jl to be loaded to work
            # When DFTK is not loaded, load_dftk throws an error
            # This is expected behavior for package extensions
        end
    end

end
